import React, { useState, useMemo } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Label } from '@/components/ui/label';
import { Switch } from '@/components/ui/switch';
import { Loader2, Link2, Send, FileText, ArrowRight } from 'lucide-react';
import { toast } from 'sonner';
import { MaterialMappingStep, MaterialMapping } from './MaterialMappingStep';

interface LinkToFinalAccountDialogProps {
  isOpen: boolean;
  onClose: () => void;
  floorPlanId: string | null;
  floorPlanName: string | null;
  projectId: string | null;
  takeoffCounts?: TakeoffCounts;
}

export interface CircuitMaterialSummary {
  count: number;
  totalLength: number;
  grossLength?: number;
  boqSection?: string | null;
  unit?: string;
  isAutoGenerated?: boolean;
}

export interface TakeoffCounts {
  equipment: Record<string, number>;
  containment: Record<string, number>;
  cables: Record<string, { count: number; totalLength: number }>;
  circuitWiring?: Record<string, CircuitMaterialSummary>;
}

// Type definitions for query results
type FinalAccountResult = { id: string; project_id: string; account_number: string; account_name: string } | null;
type BillResult = { id: string; bill_number: number; bill_name: string; display_order: number };
type SectionResult = { id: string; section_code: string; section_name: string; display_order: number };
type ShopResult = { id: string; shop_number: string; shop_name: string };

type DialogStep = 'select-location' | 'map-materials' | 'confirm';

// Helper functions with explicit any casts to avoid TS2589
async function fetchFinalAccount(projectId: string): Promise<FinalAccountResult> {
  const { data, error } = await (supabase as any)
    .from('final_accounts')
    .select('id, project_id, account_number, account_name')
    .eq('project_id', projectId)
    .maybeSingle();
  if (error) throw error;
  return data;
}

async function fetchBills(accountId: string): Promise<BillResult[]> {
  const { data, error } = await (supabase as any)
    .from('final_account_bills')
    .select('id, bill_number, bill_name, display_order')
    .eq('final_account_id', accountId)
    .order('bill_number', { ascending: true });
  if (error) throw error;
  return data || [];
}

async function fetchSections(billId: string): Promise<SectionResult[]> {
  const { data, error } = await (supabase as any)
    .from('final_account_sections')
    .select('id, section_code, section_name, display_order')
    .eq('bill_id', billId);
  if (error) throw error;
  
  // Sort numerically by section_code (e.g., 1.2 before 1.12)
  return (data || []).sort((a: SectionResult, b: SectionResult) => {
    const partsA = (a.section_code || '').split('.').map(p => parseFloat(p) || 0);
    const partsB = (b.section_code || '').split('.').map(p => parseFloat(p) || 0);
    
    for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {
      const numA = partsA[i] || 0;
      const numB = partsB[i] || 0;
      if (numA !== numB) return numA - numB;
    }
    return 0;
  });
}

async function fetchShops(sectionId: string): Promise<ShopResult[]> {
  const { data, error } = await (supabase as any)
    .from('final_account_shop_subsections')
    .select('id, shop_number, shop_name')
    .eq('section_id', sectionId)
    .order('shop_number');
  if (error) throw error;
  return data || [];
}

export const LinkToFinalAccountDialog: React.FC<LinkToFinalAccountDialogProps> = ({
  isOpen,
  onClose,
  floorPlanId,
  floorPlanName,
  projectId,
  takeoffCounts
}) => {
  const queryClient = useQueryClient();
  const [step, setStep] = useState<DialogStep>('select-location');
  const [selectedBillId, setSelectedBillId] = useState<string>('');
  const [selectedSectionId, setSelectedSectionId] = useState<string>('');
  const [selectedShopId, setSelectedShopId] = useState<string>('');
  const [transferTakeoffs, setTransferTakeoffs] = useState(false);
  const [materialMappings, setMaterialMappings] = useState<MaterialMapping[]>([]);
  const [isAlreadyLinked, setIsAlreadyLinked] = useState(false);

  // Reset state when dialog closes
  const handleClose = () => {
    setStep('select-location');
    setSelectedBillId('');
    setSelectedSectionId('');
    setSelectedShopId('');
    setTransferTakeoffs(false);
    setMaterialMappings([]);
    setIsAlreadyLinked(false);
    onClose();
  };

  // Fetch final account for project
  const { data: finalAccount } = useQuery({
    queryKey: ['final-account-for-linking', projectId],
    queryFn: () => fetchFinalAccount(projectId!),
    enabled: !!projectId && isOpen,
  });

  // Fetch existing link for this floor plan
  const { data: existingLink } = useQuery({
    queryKey: ['floor-plan-existing-link', floorPlanId],
    queryFn: async () => {
      if (!floorPlanId) return null;
      const { data, error } = await supabase
        .from('floor_plan_projects')
        .select('linked_final_account_id, linked_section_id, linked_shop_subsection_id')
        .eq('id', floorPlanId)
        .single();
      if (error) throw error;
      return data;
    },
    enabled: !!floorPlanId && isOpen,
  });

  // Fetch existing material mappings for this floor plan
  const { data: existingSavedMappings } = useQuery({
    queryKey: ['floor-plan-saved-mappings', floorPlanId],
    queryFn: async () => {
      if (!floorPlanId) return null;
      const { data, error } = await supabase
        .from('floor_plan_material_mappings')
        .select('equipment_type, equipment_label, final_account_item_id, master_material_id')
        .eq('floor_plan_id', floorPlanId);
      if (error) throw error;
      return data;
    },
    enabled: !!floorPlanId && isOpen,
  });

  // Check if we have saved mappings for this floor plan
  const hasSavedMappings = existingSavedMappings && existingSavedMappings.length > 0;

  // Fetch bills
  const { data: bills } = useQuery({
    queryKey: ['final-account-bills', finalAccount?.id],
    queryFn: () => fetchBills(finalAccount!.id),
    enabled: !!finalAccount?.id,
  });

  // Fetch sections for selected bill
  const { data: sections } = useQuery({
    queryKey: ['final-account-sections', selectedBillId],
    queryFn: () => fetchSections(selectedBillId),
    enabled: !!selectedBillId,
  });

  // Fetch shop subsections for selected section
  const { data: shops } = useQuery({
    queryKey: ['final-account-shops', selectedSectionId],
    queryFn: () => fetchShops(selectedSectionId),
    enabled: !!selectedSectionId,
  });

  // Pre-populate from existing link
  React.useEffect(() => {
    if (existingLink?.linked_section_id && bills && bills.length > 0) {
      setIsAlreadyLinked(true);
      
      // Find which bill contains the linked section
      const findBillForSection = async () => {
        const { data: sectionData } = await (supabase as any)
          .from('final_account_sections')
          .select('bill_id')
          .eq('id', existingLink.linked_section_id)
          .single();
        
        if (sectionData?.bill_id) {
          setSelectedBillId(sectionData.bill_id);
          // Wait for sections to load, then set section
          setTimeout(() => {
            setSelectedSectionId(existingLink.linked_section_id);
            if (existingLink.linked_shop_subsection_id) {
              setTimeout(() => {
                setSelectedShopId(existingLink.linked_shop_subsection_id);
              }, 100);
            }
          }, 100);
        }
      };
      
      findBillForSection();
    }
  }, [existingLink, bills]);

  // Create reference drawing mutation
  const linkMutation = useMutation({
    mutationFn: async (passedMappings?: MaterialMapping[]) => {
      if (!floorPlanId || !finalAccount?.id) throw new Error('Missing required data');

      const { data: user } = await supabase.auth.getUser();

      // Create reference drawing record
      const { data: refDrawing, error: refError } = await supabase
        .from('final_account_reference_drawings')
        .insert({
          final_account_id: finalAccount.id,
          section_id: selectedSectionId || null,
          shop_subsection_id: selectedShopId || null,
          floor_plan_id: floorPlanId,
          drawing_name: floorPlanName || 'Floor Plan',
          takeoffs_transferred: transferTakeoffs,
          transferred_at: transferTakeoffs ? new Date().toISOString() : null,
          created_by: user.user?.id,
        })
        .select()
        .single();

      if (refError) throw refError;

      // Update floor plan with linked section
      const { error: updateError } = await supabase
        .from('floor_plan_projects')
        .update({
          linked_final_account_id: finalAccount.id,
          linked_section_id: selectedSectionId || null,
          linked_shop_subsection_id: selectedShopId || null,
        })
        .eq('id', floorPlanId);

      if (updateError) throw updateError;

      // Transfer take-offs if requested - use passed mappings (from MaterialMappingStep) or state mappings
      const mappingsToUse = passedMappings || materialMappings;
      if (transferTakeoffs && takeoffCounts && selectedSectionId) {
        await transferTakeoffsToFinalAccount(
          selectedSectionId,
          selectedShopId || null,
          floorPlanId,
          refDrawing.id,
          takeoffCounts,
          mappingsToUse
        );
      }

      return refDrawing;
    },
    onSuccess: () => {
      toast.success(
        transferTakeoffs 
          ? 'Floor plan linked and take-offs transferred!' 
          : 'Floor plan linked as reference drawing!'
      );
      queryClient.invalidateQueries({ queryKey: ['final-account-reference-drawings'] });
      queryClient.invalidateQueries({ queryKey: ['floor-plan-projects'] });
      handleClose();
    },
    onError: (error) => {
      toast.error(`Failed to link: ${error.message}`);
    },
  });

  // Transfer take-offs to final account items with mappings
  const transferTakeoffsToFinalAccount = async (
    sectionId: string,
    shopSubsectionId: string | null,
    floorPlanId: string,
    refDrawingId: string,
    counts: TakeoffCounts,
    mappings: MaterialMapping[]
  ) => {
    // STEP 1: Build mapping lookup (floor plan material -> BOQ item)
    const mappingLookup = new Map<string, MaterialMapping>();
    for (const mapping of mappings) {
      mappingLookup.set(`${mapping.category}_${mapping.equipmentLabel}`, mapping);
    }

    // STEP 2: Fetch existing items from this floor plan (for re-sync/replace logic)
    const { data: existingFloorPlanItems } = await supabase
      .from('final_account_items')
      .select('id, description, item_code, section_id')
      .eq('source_floor_plan_id', floorPlanId);

    const existingItemsByDesc = new Map<string, { id: string; section_id: string }>();
    if (existingFloorPlanItems) {
      for (const item of existingFloorPlanItems) {
        existingItemsByDesc.set(item.description, { id: item.id, section_id: item.section_id });
      }
    }

    // STEP 3: Consolidate quantities by target
    // - mappedItemQuantities: BOQ items that floor plan materials are mapped to (ADD quantities)
    // - replaceItemQuantities: Items previously created from this floor plan (REPLACE quantities)
    // - itemsToInsert: New unmapped items to create
    const mappedItemQuantities = new Map<string, number>(); // finalAccountItemId -> total qty to add
    const replaceItemQuantities = new Map<string, number>(); // existing item id -> new qty
    const itemsToInsert: any[] = [];

    // Process equipment
    for (const [equipType, count] of Object.entries(counts.equipment)) {
      if (count <= 0) continue;
      
      const mapping = mappingLookup.get(`equipment_${equipType}`);
      
      if (mapping?.finalAccountItemId) {
        // MAPPED: Consolidate quantity to add to this BOQ item
        const current = mappedItemQuantities.get(mapping.finalAccountItemId) || 0;
        mappedItemQuantities.set(mapping.finalAccountItemId, current + count);
      } else {
        // UNMAPPED: Check if previously created from this floor plan
        const existingItem = existingItemsByDesc.get(equipType);
        if (existingItem) {
          replaceItemQuantities.set(existingItem.id, count);
        } else {
          // NEW: Insert as new item
          itemsToInsert.push({
            section_id: sectionId,
            shop_subsection_id: shopSubsectionId,
            item_code: equipType.toUpperCase().replace(/\s+/g, '_').substring(0, 10),
            description: equipType,
            unit: 'NO',
            contract_quantity: 0,
            final_quantity: count,
            supply_rate: 0,
            install_rate: 0,
            contract_amount: 0,
            final_amount: 0,
            source_floor_plan_id: floorPlanId,
            source_reference_drawing_id: refDrawingId,
          });
        }
      }
    }

    // Process containment
    for (const [containType, length] of Object.entries(counts.containment)) {
      if (length <= 0) continue;
      
      const mapping = mappingLookup.get(`containment_${containType}`);
      const qty = Math.round(length * 100) / 100;
      
      if (mapping?.finalAccountItemId) {
        const current = mappedItemQuantities.get(mapping.finalAccountItemId) || 0;
        mappedItemQuantities.set(mapping.finalAccountItemId, current + qty);
      } else {
        const existingItem = existingItemsByDesc.get(containType);
        if (existingItem) {
          replaceItemQuantities.set(existingItem.id, qty);
        } else {
          const targetSectionId = mapping?.finalAccountSectionId || sectionId;
          itemsToInsert.push({
            section_id: targetSectionId,
            shop_subsection_id: shopSubsectionId,
            item_code: containType.toUpperCase().replace(/\s+/g, '_').substring(0, 10),
            description: containType,
            unit: 'M',
            contract_quantity: 0,
            final_quantity: qty,
            supply_rate: 0,
            install_rate: 0,
            contract_amount: 0,
            final_amount: 0,
            source_floor_plan_id: floorPlanId,
            source_reference_drawing_id: refDrawingId,
          });
        }
      }
    }

    // Process cables
    for (const [cableType, data] of Object.entries(counts.cables)) {
      if (data.count <= 0) continue;
      
      const mapping = mappingLookup.get(`cable_${cableType}`);
      const qty = Math.round(data.totalLength * 100) / 100;
      const cableDesc = `Cable: ${cableType}`;
      
      if (mapping?.finalAccountItemId) {
        const current = mappedItemQuantities.get(mapping.finalAccountItemId) || 0;
        mappedItemQuantities.set(mapping.finalAccountItemId, current + qty);
      } else {
        const existingItem = existingItemsByDesc.get(cableDesc);
        if (existingItem) {
          replaceItemQuantities.set(existingItem.id, qty);
        } else {
          itemsToInsert.push({
            section_id: sectionId,
            shop_subsection_id: shopSubsectionId,
            item_code: cableType.toUpperCase().replace(/\s+/g, '_').substring(0, 10),
            description: cableDesc,
            unit: 'M',
            contract_quantity: 0,
            final_quantity: qty,
            supply_rate: 0,
            install_rate: 0,
            contract_amount: 0,
            final_amount: 0,
            source_floor_plan_id: floorPlanId,
            source_reference_drawing_id: refDrawingId,
          });
        }
      }
    }

    // STEP 4: Insert new unmapped items (only items not mapped and not previously from this floor plan)
    if (itemsToInsert.length > 0) {
      const { error } = await supabase
        .from('final_account_items')
        .insert(itemsToInsert);
      if (error) throw error;
    }

    // STEP 5: Update MAPPED BOQ items - ADD consolidated quantities
    for (const [itemId, qtyToAdd] of mappedItemQuantities) {
      const { data: existing } = await supabase
        .from('final_account_items')
        .select('final_quantity, supply_rate, install_rate, contract_quantity')
        .eq('id', itemId)
        .single();
      
      if (existing) {
        const currentFinalQty = existing.final_quantity ?? 0;
        const newFinalQty = currentFinalQty + qtyToAdd;
        const supplyRate = existing.supply_rate || 0;
        const installRate = existing.install_rate || 0;
        const contractQty = existing.contract_quantity || 0;
        
        const finalAmount = newFinalQty * (supplyRate + installRate);
        const contractAmount = contractQty * (supplyRate + installRate);
        const variationAmount = finalAmount - contractAmount;
        
        const { error } = await supabase
          .from('final_account_items')
          .update({ 
            final_quantity: newFinalQty,
            final_amount: finalAmount,
            contract_amount: contractAmount,
            variation_amount: variationAmount
          })
          .eq('id', itemId);
        if (error) throw error;
      }
    }

    // STEP 6: Update REPLACE items (floor plan items being re-synced) - REPLACE quantity
    for (const [itemId, newQty] of replaceItemQuantities) {
      const { data: existing } = await supabase
        .from('final_account_items')
        .select('supply_rate, install_rate, contract_quantity')
        .eq('id', itemId)
        .single();
      
      if (existing) {
        const supplyRate = existing.supply_rate || 0;
        const installRate = existing.install_rate || 0;
        const contractQty = existing.contract_quantity || 0;
        
        const finalAmount = newQty * (supplyRate + installRate);
        const contractAmount = contractQty * (supplyRate + installRate);
        const variationAmount = finalAmount - contractAmount;
        
        const { error } = await supabase
          .from('final_account_items')
          .update({ 
            final_quantity: newQty,
            final_amount: finalAmount,
            contract_amount: contractAmount,
            variation_amount: variationAmount
          })
          .eq('id', itemId);
        if (error) throw error;
      }
    }

    // Recalculate section totals for all affected sections
    const affectedSectionIds = new Set<string>();
    affectedSectionIds.add(sectionId);
    
    for (const mapping of mappings) {
      if (mapping.finalAccountSectionId) {
        affectedSectionIds.add(mapping.finalAccountSectionId);
      }
    }

    for (const secId of affectedSectionIds) {
      await recalculateSectionTotals(secId);
    }
  };

  // Helper to recalculate section totals
  const recalculateSectionTotals = async (secId: string) => {
    const { data: allItems } = await supabase
      .from('final_account_items')
      .select('id, contract_amount, final_amount, variation_amount, is_prime_cost, pc_actual_cost, pc_allowance, is_pa_item, pa_parent_item_id, pa_percentage')
      .eq('section_id', secId);

    if (allItems) {
      const itemMap = new Map(allItems.map(item => [item.id, item]));
      
      const totals = allItems.reduce(
        (acc, item) => {
          let finalAmt = Number(item.final_amount || 0);
          let contractAmt = Number(item.contract_amount || 0);
          
          if (item.is_prime_cost) {
            finalAmt = Number(item.pc_actual_cost) || 0;
            contractAmt = Number(item.pc_allowance) || Number(item.contract_amount) || 0;
          }
          
          if (item.is_pa_item && item.pa_parent_item_id) {
            const parentItem = itemMap.get(item.pa_parent_item_id);
            if (parentItem) {
              const parentActual = Number(parentItem.pc_actual_cost) || 0;
              const parentAllowance = Number(parentItem.pc_allowance) || Number(parentItem.contract_amount) || 0;
              const paPercent = Number(item.pa_percentage) || 0;
              finalAmt = parentActual * (paPercent / 100);
              contractAmt = parentAllowance * (paPercent / 100);
            }
          }
          
          return {
            contract: acc.contract + contractAmt,
            final: acc.final + finalAmt,
            variation: acc.variation + (finalAmt - contractAmt),
          };
        },
        { contract: 0, final: 0, variation: 0 }
      );

      // Get bill_id for the section
      const { data: section } = await supabase
        .from('final_account_sections')
        .select('bill_id')
        .eq('id', secId)
        .single();

      await supabase
        .from('final_account_sections')
        .update({
          contract_total: totals.contract,
          final_total: totals.final,
          variation_total: totals.variation,
        })
        .eq('id', secId);

      // Recalculate bill totals
      if (section?.bill_id) {
        const { data: billSections } = await supabase
          .from('final_account_sections')
          .select('contract_total, final_total, variation_total')
          .eq('bill_id', section.bill_id);

        if (billSections) {
          const billTotals = billSections.reduce(
            (acc, s) => ({
              contract: acc.contract + (s.contract_total || 0),
              final: acc.final + (s.final_total || 0),
              variation: acc.variation + (s.variation_total || 0),
            }),
            { contract: 0, final: 0, variation: 0 }
          );

          await supabase
            .from('final_account_bills')
            .update({
              contract_total: billTotals.contract,
              final_total: billTotals.final,
              variation_total: billTotals.variation,
            })
            .eq('id', section.bill_id);
        }
      }
    }
  };

  const hasTakeoffs = useMemo(() => {
    if (!takeoffCounts) return false;
    const equipmentTotal = Object.values(takeoffCounts.equipment).reduce((a, b) => a + b, 0);
    const containmentTotal = Object.values(takeoffCounts.containment).reduce((a, b) => a + b, 0);
    const cableTotal = Object.values(takeoffCounts.cables).reduce((a, b) => a + b.count, 0);
    const circuitWiringTotal = takeoffCounts.circuitWiring 
      ? Object.values(takeoffCounts.circuitWiring).reduce((a, b) => a + b.count, 0) 
      : 0;
    return equipmentTotal > 0 || containmentTotal > 0 || cableTotal > 0 || circuitWiringTotal > 0;
  }, [takeoffCounts]);

  // Build MaterialMapping[] from saved database mappings
  const buildMappingsFromSaved = (): MaterialMapping[] => {
    if (!existingSavedMappings || !takeoffCounts) return [];
    
    const mappings: MaterialMapping[] = [];
    
    for (const saved of existingSavedMappings) {
      let quantity = 0;
      let unit = 'Nr';
      
      if (saved.equipment_type === 'equipment') {
        quantity = takeoffCounts.equipment[saved.equipment_label] || 0;
        unit = 'Nr';
      } else if (saved.equipment_type === 'containment') {
        quantity = takeoffCounts.containment[saved.equipment_label] || 0;
        unit = 'm';
      } else if (saved.equipment_type === 'cable') {
        quantity = takeoffCounts.cables[saved.equipment_label]?.totalLength || 0;
        unit = 'm';
      } else if (saved.equipment_type === 'circuitWiring') {
        quantity = takeoffCounts.circuitWiring?.[saved.equipment_label]?.totalLength || 0;
        unit = 'm';
      }
      
      if (quantity > 0) {
        mappings.push({
          equipmentType: saved.equipment_type,
          equipmentLabel: saved.equipment_label,
          category: saved.equipment_type as 'equipment' | 'containment' | 'cable',
          quantity,
          unit,
          finalAccountItemId: saved.final_account_item_id || undefined,
          masterMaterialId: saved.master_material_id || undefined,
        });
      }
    }
    
    return mappings;
  };

  const handleNextStep = () => {
    if (!selectedSectionId) {
      toast.error('Please select a section');
      return;
    }
    
    // If already linked with saved mappings, auto-use them (no need to ask again)
    if (isAlreadyLinked && hasSavedMappings && hasTakeoffs) {
      const savedMappings = buildMappingsFromSaved();
      toast.info('Using existing material mappings to update quantities');
      linkMutation.mutate(savedMappings);
      return;
    }
    
    // Only show mapping step if we need new mappings
    if (transferTakeoffs && hasTakeoffs) {
      setStep('map-materials');
    } else {
      linkMutation.mutate(undefined);
    }
  };

  const handleMappingsComplete = (mappings: MaterialMapping[]) => {
    setMaterialMappings(mappings);
    linkMutation.mutate(mappings); // Pass mappings directly to avoid stale state
  };

  const renderStep = () => {
    if (step === 'map-materials' && floorPlanId && projectId && selectedSectionId && takeoffCounts && finalAccount?.id) {
      return (
        <MaterialMappingStep
          projectId={projectId}
          floorPlanId={floorPlanId}
          sectionId={selectedSectionId}
          finalAccountId={finalAccount.id}
          takeoffCounts={takeoffCounts}
          onMappingsComplete={handleMappingsComplete}
          onBack={() => setStep('select-location')}
        />
      );
    }

    return (
      <>
        <div className="space-y-4 py-4">
          {/* Show already linked status */}
          {isAlreadyLinked && (
            <div className="rounded-lg border border-primary/30 bg-primary/5 p-3 text-sm">
              <div className="flex items-center gap-2 text-primary font-medium">
                <Link2 className="h-4 w-4" />
                Already Linked
              </div>
              <p className="text-muted-foreground mt-1">
                This floor plan is already linked to a Final Account section. You can update the link or transfer additional take-offs.
              </p>
            </div>
          )}

          {!finalAccount ? (
            <div className="text-center py-4 text-muted-foreground">
              <FileText className="h-8 w-8 mx-auto mb-2 opacity-50" />
              <p>No Final Account found for this project.</p>
              <p className="text-sm">Create a Final Account first.</p>
            </div>
          ) : (
            <>
              {/* Bill Selection */}
              <div className="space-y-2">
                <Label>Bill</Label>
                <Select value={selectedBillId} onValueChange={(v) => {
                  setSelectedBillId(v);
                  setSelectedSectionId('');
                  setSelectedShopId('');
                }}>
                  <SelectTrigger>
                    <SelectValue placeholder="Select a bill..." />
                  </SelectTrigger>
                  <SelectContent>
                    {bills?.map((bill) => (
                      <SelectItem key={bill.id} value={bill.id}>
                        Bill {bill.bill_number}: {bill.bill_name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              {/* Section Selection */}
              {selectedBillId && (
                <div className="space-y-2">
                  <Label>Section</Label>
                  <Select value={selectedSectionId} onValueChange={(v) => {
                    setSelectedSectionId(v);
                    setSelectedShopId('');
                  }}>
                    <SelectTrigger>
                      <SelectValue placeholder="Select a section..." />
                    </SelectTrigger>
                    <SelectContent>
                      {sections?.map((section) => (
                        <SelectItem key={section.id} value={section.id}>
                          {section.section_code}: {section.section_name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              )}

              {/* Shop Selection (optional) */}
              {selectedSectionId && shops && shops.length > 0 && (
                <div className="space-y-2">
                  <Label>Shop (Optional)</Label>
                  <Select 
                    value={selectedShopId || 'all'} 
                    onValueChange={(v) => setSelectedShopId(v === 'all' ? '' : v)}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="All shops in section..." />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">All shops</SelectItem>
                      {shops.map((shop) => (
                        <SelectItem key={shop.id} value={shop.id}>
                          {shop.shop_number}: {shop.shop_name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              )}

              {/* Auto-sync info for already linked with mappings */}
              {selectedSectionId && isAlreadyLinked && hasSavedMappings && hasTakeoffs && (
                <div className="rounded-lg border border-primary/30 bg-primary/5 p-4">
                  <div className="flex items-center gap-2 text-primary font-medium">
                    <Send className="h-4 w-4" />
                    Auto-Sync Enabled
                  </div>
                  <p className="text-sm text-muted-foreground mt-1">
                    Material mappings are already configured. Quantities will be automatically updated in the Final Account using your saved mappings.
                  </p>
                  {takeoffCounts && (
                    <ul className="mt-2 space-y-1 text-sm text-muted-foreground">
                      {Object.entries(takeoffCounts.equipment).map(([type, count]) => 
                        count > 0 && <li key={type}>• {type}: {count} no.</li>
                      )}
                      {Object.entries(takeoffCounts.containment).map(([type, length]) => 
                        length > 0 && <li key={type}>• {type}: {length.toFixed(1)}m</li>
                      )}
                      {Object.entries(takeoffCounts.cables).map(([type, data]) => 
                        data.count > 0 && <li key={type}>• {type}: {data.count} runs ({data.totalLength.toFixed(1)}m)</li>
                      )}
                      {takeoffCounts.circuitWiring && Object.entries(takeoffCounts.circuitWiring).map(([type, data]) => 
                        data.count > 0 && <li key={`wiring-${type}`}>• Circuit Wiring ({type}): {data.count} runs ({data.totalLength.toFixed(1)}m)</li>
                      )}
                    </ul>
                  )}
                </div>
              )}

              {/* Transfer Take-offs Toggle - only show if NOT already linked with mappings */}
              {selectedSectionId && !(isAlreadyLinked && hasSavedMappings && hasTakeoffs) && (
                <div className="flex items-center justify-between rounded-lg border p-4">
                  <div className="space-y-0.5">
                    <Label className="flex items-center gap-2">
                      <Send className="h-4 w-4" />
                      Transfer Take-offs
                    </Label>
                    <p className="text-sm text-muted-foreground">
                      {hasTakeoffs 
                        ? 'Auto-populate Final Account items with quantities from this drawing'
                        : 'No equipment/containment/cables marked on this drawing yet'
                      }
                    </p>
                  </div>
                  <Switch
                    checked={transferTakeoffs}
                    onCheckedChange={setTransferTakeoffs}
                    disabled={!hasTakeoffs}
                  />
                </div>
              )}

              {/* Take-off Preview for new mappings */}
              {transferTakeoffs && takeoffCounts && !(isAlreadyLinked && hasSavedMappings) && (
                <div className="rounded-lg border bg-muted/50 p-3 text-sm">
                  <div className="font-medium mb-2">Items to transfer:</div>
                  <ul className="space-y-1 text-muted-foreground">
                    {Object.entries(takeoffCounts.equipment).map(([type, count]) => 
                      count > 0 && <li key={type}>• {type}: {count} no.</li>
                    )}
                    {Object.entries(takeoffCounts.containment).map(([type, length]) => 
                      length > 0 && <li key={type}>• {type}: {length.toFixed(1)}m</li>
                    )}
                    {Object.entries(takeoffCounts.cables).map(([type, data]) => 
                      data.count > 0 && <li key={type}>• {type}: {data.count} runs ({data.totalLength.toFixed(1)}m)</li>
                    )}
                  </ul>
                  
                  {/* Circuit Wiring - Net quantities (measured = installed = claimed) */}
                  {takeoffCounts.circuitWiring && Object.keys(takeoffCounts.circuitWiring).length > 0 && (
                    <div className="mt-3 pt-3 border-t border-border/50">
                      <div className="font-medium mb-2 text-foreground">Circuit Materials:</div>
                      <ul className="space-y-1 text-muted-foreground">
                        {Object.entries(takeoffCounts.circuitWiring).map(([type, data]) => 
                          data.count > 0 && (
                            <li key={`wiring-${type}`}>
                              • {type}: {data.count} runs ({data.totalLength.toFixed(1)}m)
                            </li>
                          )
                        )}
                      </ul>
                    </div>
                  )}
                  
                  {transferTakeoffs && (
                    <p className="mt-2 text-xs text-primary">
                      Next step: Map items to BOQ entries for accurate rates
                    </p>
                  )}
                </div>
              )}
            </>
          )}
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={handleClose}>Cancel</Button>
          <Button 
            onClick={handleNextStep} 
            disabled={linkMutation.isPending || !finalAccount || !selectedSectionId}
          >
            {linkMutation.isPending ? (
              <><Loader2 className="h-4 w-4 mr-2 animate-spin" /> Linking...</>
            ) : transferTakeoffs && hasTakeoffs ? (
              <>Next: Map Materials <ArrowRight className="h-4 w-4 ml-2" /></>
            ) : (
              <><Link2 className="h-4 w-4 mr-2" /> Link Drawing</>
            )}
          </Button>
        </DialogFooter>
      </>
    );
  };

  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && handleClose()}>
      <DialogContent className={step === 'map-materials' ? 'sm:max-w-2xl' : 'sm:max-w-md'}>
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Link2 className="h-5 w-5" />
            {step === 'map-materials' ? 'Map Materials to BOQ' : 'Link to Final Account'}
          </DialogTitle>
          <DialogDescription>
            {step === 'map-materials' 
              ? 'Match floor plan items to existing BOQ or Master Material entries for accurate costing.'
              : (
                <>
                  Link this floor plan as a reference drawing for the Final Account.
                  {floorPlanName && <span className="block mt-1 font-medium text-foreground">"{floorPlanName}"</span>}
                </>
              )
            }
          </DialogDescription>
        </DialogHeader>

        {renderStep()}
      </DialogContent>
    </Dialog>
  );
};
